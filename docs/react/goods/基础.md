---
id: reactBase
title: react 基础
hide_title: true
sidebar_label: 基础
---

## 组件类

### 1. Component

用 `class` 申明组件的基类

```jsx
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

### 2. PureComponent

`[pjʊr]：adj. (pure) 纯的；纯粹的；纯洁的；`

`PureComponent` 和 `Component` 用法，差不多一样，

```jsx {13}
class Index extends React.PureComponent{
  constructor(props){
      super(props)
      this.state={
          data:{
            name:'alien',
            age:28
          }
      }
  }
  handerClick= () =>{
      const { data } = this.state
      data.age++
      this.setState({ data })
  }
  render(){
      const { data } = this.state
      return <div className="box" >
      <div className="show" >
          <div> 年龄： { data.age  }</div>
          <button onClick={ this.handerClick } >age++</button>
      </div>
  </div>
  }
}
```

:::warning 点击按钮没有反应

- 纯组件 `PureComponent` 会浅比较，`props 和 `state` 是否相同，来决定是否重新渲染组件。所以一般用于性能调优，减少 `render` 次数。

- 浅比较，因为 `data state` 是个对象，引用没有发生变化，所以浅比较是没有变化的，不会触发渲染。

- 如何解决

  ```jsx
  this.setState({ data:{...data} })
  ```

:::

### 3. memo

和 `PureComponent` 类似，但是 `React.memo`，`“只会对 props进行浅比较”`，组件内部的 `state, context` 变化，仍然会触发 `render`。

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  /* 使用 props 渲染 */
});
```

:::success
- 默认通过[浅比较](/react/goods/reactShallowCompare) 判断是否进行渲染，也可以自定义判断

  ```js
  function MyComponent(props) {
    /* 使用 props 渲染 */
  }
  function areEqual(prevProps, nextProps) {
    /*
    如果把 nextProps 传入 render 方法的返回结果与
    将 prevProps 传入 render 方法的返回结果一致则返回 true，
    否则返回 false
    */
  }
  export default React.memo(MyComponent, areEqual);
  ```

:::

### 4. forwardRef

转发`ref`, 比如父组件想获取孙组件，某一个dom元素。这种隔代ref获取引用，就需要forwardRef来助力。

```tsx
const Parent = React.forwardRef<HTMLDivElement>((prop, ref) => <p ref={ref}>1</p>)

function Combine() {
  const item = React.useRef(null)

  React.useEffect(() => {
    console.log()
  })
  return (
    <div>
      <Parent ref={item} />
    </div>
  )
}
```

:::success

- 也就是当子组件挂载的时候，会调用传递过去的 `ref`
- react不允许ref通过props传递，因为组件上已经有 ref 这个属性,在组件调和过程中，已经被特殊处理，forwardRef出现就是解决这个问题，把ref转发到自定义的forwardRef定义的属性上，让ref，可以通过props传递。
:::

### 5. lazy

React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。

```jsx
import Test from './comTest'
const LazyComponent =  React.lazy(()=> new Promise((resolve)=>{
      setTimeout(()=>{
          resolve({
              default: ()=> <Test />
          })
      },2000)
}))
class index extends React.Component{
    render(){
        return <div className="context_box"  style={ { marginTop :'50px' } }   >
           <React.Suspense fallback={ <div className="icon" ><SyncOutlined  spin  /></div> } >
               <LazyComponent />
           </React.Suspense>
        </div>
    }
}
```

### 6. Suspense

配合 `lazy` 实现异步渲染组件目的。

```jsx
const ProfilePage = React.lazy(() => import('./ProfilePage')); // 懒加载
<Suspense fallback={<Spinner />}>
  <ProfilePage />
</Suspense>
```

### 7. Fragment

同 `<></>` 一样提供包裹组件功能

```jsx
<Fragment>
   <span></span>
   <span></span>
   <span></span>
</Fragment>
```

:::warning
和 `Fragment` 区别是，`Fragment` 可以支持 `key` 属性。`<></>` 不支持 `key` 属性。
:::

### 8. Profiler

Profiler这个api一般用于开发阶段，性能检测，检测一次react组件渲染用时，性能开销。

```jsx
const index = () => {
  const callback = (...arg) => console.log(arg)
  return <div >
    <div >
      <Profiler id="root" onRender={ callback }  >
        <Router  >
          <Meuns/>
          <KeepaliveRouterSwitch withoutRoute >
              { renderRoutes(menusList) }
          </KeepaliveRouterSwitch>
        </Router>
      </Profiler>
    </div>
  </div>
}
```

### 9. StrictMode

StrictMode见名知意，严格模式，用于检测react项目中的潜在的问题，。与 Fragment 一样， StrictMode 不会渲染任何可见的 UI 。它为其后代元素触发额外的检查和警告。

```jsx
<React.StrictMode>
  <Router  >
      <Meuns/>
      <KeepaliveRouterSwitch withoutRoute >
          { renderRoutes(menusList) }
      </KeepaliveRouterSwitch>
  </Router>
</React.StrictMode>
```
