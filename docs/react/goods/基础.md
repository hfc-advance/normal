---
id: reactBase
title: react 基础
hide_title: true
sidebar_label: 基础
---

## 组件类

### 1. Component

用 `class` 申明组件的基类

```jsx
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

### 2. PureComponent

`[pjʊr]：adj. (pure) 纯的；纯粹的；纯洁的；`

`PureComponent` 和 `Component` 用法，差不多一样，

```jsx {13}
class Index extends React.PureComponent{
  constructor(props){
      super(props)
      this.state={
          data:{
            name:'alien',
            age:28
          }
      }
  }
  handerClick= () =>{
      const { data } = this.state
      data.age++
      this.setState({ data })
  }
  render(){
      const { data } = this.state
      return <div className="box" >
      <div className="show" >
          <div> 年龄： { data.age  }</div>
          <button onClick={ this.handerClick } >age++</button>
      </div>
  </div>
  }
}
```

:::warning 点击按钮没有反应

- 纯组件 `PureComponent` 会浅比较，`props 和 `state` 是否相同，来决定是否重新渲染组件。所以一般用于性能调优，减少 `render` 次数。

- 浅比较，因为 `data state` 是个对象，引用没有发生变化，所以浅比较是没有变化的，不会触发渲染。

- 如何解决

  ```jsx
  this.setState({ data:{...data} })
  ```

:::

### 3. memo

和 `PureComponent` 类似，但是 `React.memo`，`“只会对 props进行浅比较”`，组件内部的 `state, context` 变化，仍然会触发 `render`。

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  /* 使用 props 渲染 */
});
```

:::success
:::
